{"ast":null,"code":"'use strict';import invariant from'fbjs/lib/invariant';function elementsThatOverlapOffsets(offsets,itemCount,getFrameMetrics){var out=[];var outLength=0;for(var ii=0;ii<itemCount;ii++){var frame=getFrameMetrics(ii);var trailingOffset=frame.offset+frame.length;for(var kk=0;kk<offsets.length;kk++){if(out[kk]==null&&trailingOffset>=offsets[kk]){out[kk]=ii;outLength++;if(kk===offsets.length-1){invariant(outLength===offsets.length,'bad offsets input, should be in increasing order: %s',JSON.stringify(offsets));return out;}}}}return out;}function newRangeCount(prev,next){return next.last-next.first+1-Math.max(0,1+Math.min(next.last,prev.last)-Math.max(next.first,prev.first));}function computeWindowedRenderLimits(props,prev,getFrameMetricsApprox,scrollMetrics){var data=props.data,getItemCount=props.getItemCount,maxToRenderPerBatch=props.maxToRenderPerBatch,windowSize=props.windowSize;var itemCount=getItemCount(data);if(itemCount===0){return prev;}var offset=scrollMetrics.offset,velocity=scrollMetrics.velocity,visibleLength=scrollMetrics.visibleLength;var visibleBegin=Math.max(0,offset);var visibleEnd=visibleBegin+visibleLength;var overscanLength=(windowSize-1)*visibleLength;var leadFactor=0.5;var fillPreference=velocity>1?'after':velocity<-1?'before':'none';var overscanBegin=Math.max(0,visibleBegin-(1-leadFactor)*overscanLength);var overscanEnd=Math.max(0,visibleEnd+leadFactor*overscanLength);var lastItemOffset=getFrameMetricsApprox(itemCount-1).offset;if(lastItemOffset<overscanBegin){return{first:Math.max(0,itemCount-1-maxToRenderPerBatch),last:itemCount-1};}var _elementsThatOverlapO=elementsThatOverlapOffsets([overscanBegin,visibleBegin,visibleEnd,overscanEnd],props.getItemCount(props.data),getFrameMetricsApprox),overscanFirst=_elementsThatOverlapO[0],first=_elementsThatOverlapO[1],last=_elementsThatOverlapO[2],overscanLast=_elementsThatOverlapO[3];overscanFirst=overscanFirst==null?0:overscanFirst;first=first==null?Math.max(0,overscanFirst):first;overscanLast=overscanLast==null?itemCount-1:overscanLast;last=last==null?Math.min(overscanLast,first+maxToRenderPerBatch-1):last;var visible={first:first,last:last};var newCellCount=newRangeCount(prev,visible);while(true){if(first<=overscanFirst&&last>=overscanLast){break;}var maxNewCells=newCellCount>=maxToRenderPerBatch;var firstWillAddMore=first<=prev.first||first>prev.last;var firstShouldIncrement=first>overscanFirst&&(!maxNewCells||!firstWillAddMore);var lastWillAddMore=last>=prev.last||last<prev.first;var lastShouldIncrement=last<overscanLast&&(!maxNewCells||!lastWillAddMore);if(maxNewCells&&!firstShouldIncrement&&!lastShouldIncrement){break;}if(firstShouldIncrement&&!(fillPreference==='after'&&lastShouldIncrement&&lastWillAddMore)){if(firstWillAddMore){newCellCount++;}first--;}if(lastShouldIncrement&&!(fillPreference==='before'&&firstShouldIncrement&&firstWillAddMore)){if(lastWillAddMore){newCellCount++;}last++;}}if(!(last>=first&&first>=0&&last<itemCount&&first>=overscanFirst&&last<=overscanLast&&first<=visible.first&&last>=visible.last)){throw new Error('Bad window calculation '+JSON.stringify({first:first,last:last,itemCount:itemCount,overscanFirst:overscanFirst,overscanLast:overscanLast,visible:visible}));}return{first:first,last:last};}var VirtualizeUtils={computeWindowedRenderLimits:computeWindowedRenderLimits,elementsThatOverlapOffsets:elementsThatOverlapOffsets,newRangeCount:newRangeCount};export{computeWindowedRenderLimits,elementsThatOverlapOffsets,newRangeCount};export default VirtualizeUtils;","map":{"version":3,"names":["invariant","elementsThatOverlapOffsets","offsets","itemCount","getFrameMetrics","out","outLength","ii","frame","trailingOffset","offset","length","kk","JSON","stringify","newRangeCount","prev","next","last","first","Math","max","min","computeWindowedRenderLimits","props","getFrameMetricsApprox","scrollMetrics","data","getItemCount","maxToRenderPerBatch","windowSize","velocity","visibleLength","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","lastItemOffset","_elementsThatOverlapO","overscanFirst","overscanLast","visible","newCellCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","VirtualizeUtils"],"sources":["C:/Users/Ahmed Hamza/Desktop/Mal3ab project/Mala3b-Project/node_modules/react-native-web/dist/vendor/react-native/VirtualizeUtils/index.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n */\r\n'use strict';\r\n\r\nimport invariant from 'fbjs/lib/invariant';\r\n/**\r\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\r\n * items that bound different windows of content, such as the visible area or the buffered overscan\r\n * area.\r\n */\r\n\r\nfunction elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {\r\n  var out = [];\r\n  var outLength = 0;\r\n\r\n  for (var ii = 0; ii < itemCount; ii++) {\r\n    var frame = getFrameMetrics(ii);\r\n    var trailingOffset = frame.offset + frame.length;\r\n\r\n    for (var kk = 0; kk < offsets.length; kk++) {\r\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\r\n        out[kk] = ii;\r\n        outLength++;\r\n\r\n        if (kk === offsets.length - 1) {\r\n          invariant(outLength === offsets.length, 'bad offsets input, should be in increasing order: %s', JSON.stringify(offsets));\r\n          return out;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return out;\r\n}\r\n/**\r\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\r\n * Handy for calculating how many new items will be rendered when the render window changes so we\r\n * can restrict the number of new items render at once so that content can appear on the screen\r\n * faster.\r\n */\r\n\r\n\r\nfunction newRangeCount(prev, next) {\r\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\r\n}\r\n/**\r\n * Custom logic for determining which items should be rendered given the current frame and scroll\r\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\r\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\r\n * biased in the direction of scroll.\r\n */\r\n\r\n\r\nfunction computeWindowedRenderLimits(props, prev, getFrameMetricsApprox, scrollMetrics) {\r\n  var data = props.data,\r\n      getItemCount = props.getItemCount,\r\n      maxToRenderPerBatch = props.maxToRenderPerBatch,\r\n      windowSize = props.windowSize;\r\n  var itemCount = getItemCount(data);\r\n\r\n  if (itemCount === 0) {\r\n    return prev;\r\n  }\r\n\r\n  var offset = scrollMetrics.offset,\r\n      velocity = scrollMetrics.velocity,\r\n      visibleLength = scrollMetrics.visibleLength; // Start with visible area, then compute maximum overscan region by expanding from there, biased\r\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\r\n  // too.\r\n\r\n  var visibleBegin = Math.max(0, offset);\r\n  var visibleEnd = visibleBegin + visibleLength;\r\n  var overscanLength = (windowSize - 1) * visibleLength; // Considering velocity seems to introduce more churn than it's worth.\r\n\r\n  var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\r\n\r\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\r\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\r\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\r\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\r\n\r\n  if (lastItemOffset < overscanBegin) {\r\n    // Entire list is before our overscan window\r\n    return {\r\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\r\n      last: itemCount - 1\r\n    };\r\n  } // Find the indices that correspond to the items at the render boundaries we're targeting.\r\n\r\n\r\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props.getItemCount(props.data), getFrameMetricsApprox),\r\n      overscanFirst = _elementsThatOverlapO[0],\r\n      first = _elementsThatOverlapO[1],\r\n      last = _elementsThatOverlapO[2],\r\n      overscanLast = _elementsThatOverlapO[3];\r\n\r\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\r\n  first = first == null ? Math.max(0, overscanFirst) : first;\r\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\r\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\r\n  var visible = {\r\n    first: first,\r\n    last: last\r\n  }; // We want to limit the number of new cells we're rendering per batch so that we can fill the\r\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\r\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\r\n  // render.\r\n\r\n  var newCellCount = newRangeCount(prev, visible);\r\n\r\n  while (true) {\r\n    if (first <= overscanFirst && last >= overscanLast) {\r\n      // If we fill the entire overscan range, we're done.\r\n      break;\r\n    }\r\n\r\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\r\n    var firstWillAddMore = first <= prev.first || first > prev.last;\r\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\r\n    var lastWillAddMore = last >= prev.last || last < prev.first;\r\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\r\n\r\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\r\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\r\n      // without rendering new items. This let's us preserve as many already rendered items as\r\n      // possible, reducing render churn and keeping the rendered overscan range as large as\r\n      // possible.\r\n      break;\r\n    }\r\n\r\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\r\n      if (firstWillAddMore) {\r\n        newCellCount++;\r\n      }\r\n\r\n      first--;\r\n    }\r\n\r\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\r\n      if (lastWillAddMore) {\r\n        newCellCount++;\r\n      }\r\n\r\n      last++;\r\n    }\r\n  }\r\n\r\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\r\n    throw new Error('Bad window calculation ' + JSON.stringify({\r\n      first: first,\r\n      last: last,\r\n      itemCount: itemCount,\r\n      overscanFirst: overscanFirst,\r\n      overscanLast: overscanLast,\r\n      visible: visible\r\n    }));\r\n  }\r\n\r\n  return {\r\n    first: first,\r\n    last: last\r\n  };\r\n}\r\n\r\nvar VirtualizeUtils = {\r\n  computeWindowedRenderLimits: computeWindowedRenderLimits,\r\n  elementsThatOverlapOffsets: elementsThatOverlapOffsets,\r\n  newRangeCount: newRangeCount\r\n};\r\nexport { computeWindowedRenderLimits, elementsThatOverlapOffsets, newRangeCount };\r\nexport default VirtualizeUtils;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}