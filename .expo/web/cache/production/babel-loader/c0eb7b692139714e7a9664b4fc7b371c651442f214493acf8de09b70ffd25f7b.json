{"ast":null,"code":"import Dimensions from\"../../exports/Dimensions\";import findNodeHandle from\"../../exports/findNodeHandle\";import invariant from'fbjs/lib/invariant';import Platform from\"../../exports/Platform\";import TextInputState from\"../TextInputState\";import UIManager from\"../../exports/UIManager\";import warning from'fbjs/lib/warning';var emptyObject={};var IS_ANIMATING_TOUCH_START_THRESHOLD_MS=16;var ScrollResponderMixin={scrollResponderMixinGetInitialState:function scrollResponderMixinGetInitialState(){return{isTouching:false,lastMomentumScrollBeginTime:0,lastMomentumScrollEndTime:0,observedScrollSinceBecomingResponder:false,becameResponderWhileAnimating:false};},scrollResponderHandleScrollShouldSetResponder:function scrollResponderHandleScrollShouldSetResponder(){return this.state.isTouching;},scrollResponderHandleStartShouldSetResponder:function scrollResponderHandleStartShouldSetResponder(){return false;},scrollResponderHandleStartShouldSetResponderCapture:function scrollResponderHandleStartShouldSetResponderCapture(e){return this.scrollResponderIsAnimating();},scrollResponderHandleResponderReject:function scrollResponderHandleResponderReject(){warning(false,\"ScrollView doesn't take rejection well - scrolls anyway\");},scrollResponderHandleTerminationRequest:function scrollResponderHandleTerminationRequest(){return!this.state.observedScrollSinceBecomingResponder;},scrollResponderHandleTouchEnd:function scrollResponderHandleTouchEnd(e){var nativeEvent=e.nativeEvent;this.state.isTouching=nativeEvent.touches.length!==0;this.props.onTouchEnd&&this.props.onTouchEnd(e);},scrollResponderHandleResponderRelease:function scrollResponderHandleResponderRelease(e){this.props.onResponderRelease&&this.props.onResponderRelease(e);var currentlyFocusedTextInput=TextInputState.currentlyFocusedField();if(!this.props.keyboardShouldPersistTaps&&currentlyFocusedTextInput!=null&&e.target!==currentlyFocusedTextInput&&!this.state.observedScrollSinceBecomingResponder&&!this.state.becameResponderWhileAnimating){this.props.onScrollResponderKeyboardDismissed&&this.props.onScrollResponderKeyboardDismissed(e);TextInputState.blurTextInput(currentlyFocusedTextInput);}},scrollResponderHandleScroll:function scrollResponderHandleScroll(e){this.state.observedScrollSinceBecomingResponder=true;this.props.onScroll&&this.props.onScroll(e);},scrollResponderHandleResponderGrant:function scrollResponderHandleResponderGrant(e){this.state.observedScrollSinceBecomingResponder=false;this.props.onResponderGrant&&this.props.onResponderGrant(e);this.state.becameResponderWhileAnimating=this.scrollResponderIsAnimating();},scrollResponderHandleScrollBeginDrag:function scrollResponderHandleScrollBeginDrag(e){this.props.onScrollBeginDrag&&this.props.onScrollBeginDrag(e);},scrollResponderHandleScrollEndDrag:function scrollResponderHandleScrollEndDrag(e){this.props.onScrollEndDrag&&this.props.onScrollEndDrag(e);},scrollResponderHandleMomentumScrollBegin:function scrollResponderHandleMomentumScrollBegin(e){this.state.lastMomentumScrollBeginTime=Date.now();this.props.onMomentumScrollBegin&&this.props.onMomentumScrollBegin(e);},scrollResponderHandleMomentumScrollEnd:function scrollResponderHandleMomentumScrollEnd(e){this.state.lastMomentumScrollEndTime=Date.now();this.props.onMomentumScrollEnd&&this.props.onMomentumScrollEnd(e);},scrollResponderHandleTouchStart:function scrollResponderHandleTouchStart(e){this.state.isTouching=true;this.props.onTouchStart&&this.props.onTouchStart(e);},scrollResponderHandleTouchMove:function scrollResponderHandleTouchMove(e){this.props.onTouchMove&&this.props.onTouchMove(e);},scrollResponderIsAnimating:function scrollResponderIsAnimating(){var now=Date.now();var timeSinceLastMomentumScrollEnd=now-this.state.lastMomentumScrollEndTime;var isAnimating=timeSinceLastMomentumScrollEnd<IS_ANIMATING_TOUCH_START_THRESHOLD_MS||this.state.lastMomentumScrollEndTime<this.state.lastMomentumScrollBeginTime;return isAnimating;},scrollResponderGetScrollableNode:function scrollResponderGetScrollableNode(){return this.getScrollableNode?this.getScrollableNode():findNodeHandle(this);},scrollResponderScrollTo:function scrollResponderScrollTo(x,y,animated){if(typeof x==='number'){console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');}else{var _ref=x||emptyObject;x=_ref.x;y=_ref.y;animated=_ref.animated;}var node=this.scrollResponderGetScrollableNode();var left=x||0;var top=y||0;if(typeof node.scroll==='function'){node.scroll({top:top,left:left,behavior:!animated?'auto':'smooth'});}else{node.scrollLeft=left;node.scrollTop=top;}},scrollResponderZoomTo:function scrollResponderZoomTo(rect,animated){if(Platform.OS!=='ios'){invariant('zoomToRect is not implemented');}},scrollResponderFlashScrollIndicators:function scrollResponderFlashScrollIndicators(){},scrollResponderScrollNativeHandleToKeyboard:function scrollResponderScrollNativeHandleToKeyboard(nodeHandle,additionalOffset,preventNegativeScrollOffset){this.additionalScrollOffset=additionalOffset||0;this.preventNegativeScrollOffset=!!preventNegativeScrollOffset;UIManager.measureLayout(nodeHandle,findNodeHandle(this.getInnerViewNode()),this.scrollResponderTextInputFocusError,this.scrollResponderInputMeasureAndScrollToKeyboard);},scrollResponderInputMeasureAndScrollToKeyboard:function scrollResponderInputMeasureAndScrollToKeyboard(left,top,width,height){var keyboardScreenY=Dimensions.get('window').height;if(this.keyboardWillOpenTo){keyboardScreenY=this.keyboardWillOpenTo.endCoordinates.screenY;}var scrollOffsetY=top-keyboardScreenY+height+this.additionalScrollOffset;if(this.preventNegativeScrollOffset){scrollOffsetY=Math.max(0,scrollOffsetY);}this.scrollResponderScrollTo({x:0,y:scrollOffsetY,animated:true});this.additionalOffset=0;this.preventNegativeScrollOffset=false;},scrollResponderTextInputFocusError:function scrollResponderTextInputFocusError(e){console.error('Error measuring text field: ',e);},UNSAFE_componentWillMount:function UNSAFE_componentWillMount(){this.keyboardWillOpenTo=null;this.additionalScrollOffset=0;},scrollResponderKeyboardWillShow:function scrollResponderKeyboardWillShow(e){this.keyboardWillOpenTo=e;this.props.onKeyboardWillShow&&this.props.onKeyboardWillShow(e);},scrollResponderKeyboardWillHide:function scrollResponderKeyboardWillHide(e){this.keyboardWillOpenTo=null;this.props.onKeyboardWillHide&&this.props.onKeyboardWillHide(e);},scrollResponderKeyboardDidShow:function scrollResponderKeyboardDidShow(e){if(e){this.keyboardWillOpenTo=e;}this.props.onKeyboardDidShow&&this.props.onKeyboardDidShow(e);},scrollResponderKeyboardDidHide:function scrollResponderKeyboardDidHide(e){this.keyboardWillOpenTo=null;this.props.onKeyboardDidHide&&this.props.onKeyboardDidHide(e);}};var ScrollResponder={Mixin:ScrollResponderMixin};export default ScrollResponder;","map":{"version":3,"names":["Dimensions","findNodeHandle","invariant","Platform","TextInputState","UIManager","warning","emptyObject","IS_ANIMATING_TOUCH_START_THRESHOLD_MS","ScrollResponderMixin","scrollResponderMixinGetInitialState","isTouching","lastMomentumScrollBeginTime","lastMomentumScrollEndTime","observedScrollSinceBecomingResponder","becameResponderWhileAnimating","scrollResponderHandleScrollShouldSetResponder","state","scrollResponderHandleStartShouldSetResponder","scrollResponderHandleStartShouldSetResponderCapture","e","scrollResponderIsAnimating","scrollResponderHandleResponderReject","scrollResponderHandleTerminationRequest","scrollResponderHandleTouchEnd","nativeEvent","touches","length","props","onTouchEnd","scrollResponderHandleResponderRelease","onResponderRelease","currentlyFocusedTextInput","currentlyFocusedField","keyboardShouldPersistTaps","target","onScrollResponderKeyboardDismissed","blurTextInput","scrollResponderHandleScroll","onScroll","scrollResponderHandleResponderGrant","onResponderGrant","scrollResponderHandleScrollBeginDrag","onScrollBeginDrag","scrollResponderHandleScrollEndDrag","onScrollEndDrag","scrollResponderHandleMomentumScrollBegin","Date","now","onMomentumScrollBegin","scrollResponderHandleMomentumScrollEnd","onMomentumScrollEnd","scrollResponderHandleTouchStart","onTouchStart","scrollResponderHandleTouchMove","onTouchMove","timeSinceLastMomentumScrollEnd","isAnimating","scrollResponderGetScrollableNode","getScrollableNode","scrollResponderScrollTo","x","y","animated","console","warn","_ref","node","left","top","scroll","behavior","scrollLeft","scrollTop","scrollResponderZoomTo","rect","OS","scrollResponderFlashScrollIndicators","scrollResponderScrollNativeHandleToKeyboard","nodeHandle","additionalOffset","preventNegativeScrollOffset","additionalScrollOffset","measureLayout","getInnerViewNode","scrollResponderTextInputFocusError","scrollResponderInputMeasureAndScrollToKeyboard","width","height","keyboardScreenY","get","keyboardWillOpenTo","endCoordinates","screenY","scrollOffsetY","Math","max","error","UNSAFE_componentWillMount","scrollResponderKeyboardWillShow","onKeyboardWillShow","scrollResponderKeyboardWillHide","onKeyboardWillHide","scrollResponderKeyboardDidShow","onKeyboardDidShow","scrollResponderKeyboardDidHide","onKeyboardDidHide","ScrollResponder","Mixin"],"sources":["C:/Users/Ahmed Hamza/Desktop/Mal3ab project/Mala3b-Project/node_modules/react-native-web/dist/modules/ScrollResponder/index.js"],"sourcesContent":["/**\r\n * Copyright (c) Nicolas Gallagher.\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\r\nimport Dimensions from '../../exports/Dimensions';\r\nimport findNodeHandle from '../../exports/findNodeHandle';\r\nimport invariant from 'fbjs/lib/invariant';\r\nimport Platform from '../../exports/Platform';\r\nimport TextInputState from '../TextInputState';\r\nimport UIManager from '../../exports/UIManager';\r\nimport warning from 'fbjs/lib/warning';\r\n/**\r\n * Mixin that can be integrated in order to handle scrolling that plays well\r\n * with `ResponderEventPlugin`. Integrate with your platform specific scroll\r\n * views, or even your custom built (every-frame animating) scroll views so that\r\n * all of these systems play well with the `ResponderEventPlugin`.\r\n *\r\n * iOS scroll event timing nuances:\r\n * ===============================\r\n *\r\n *\r\n * Scrolling without bouncing, if you touch down:\r\n * -------------------------------\r\n *\r\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\r\n *    ... physical touch starts ...\r\n * 2. `onTouchStartCapture`   (when you press down to stop the scroll)\r\n * 3. `onTouchStart`          (same, but bubble phase)\r\n * 4. `onResponderRelease`    (when lifting up - you could pause forever before * lifting)\r\n * 5. `onMomentumScrollEnd`\r\n *\r\n *\r\n * Scrolling with bouncing, if you touch down:\r\n * -------------------------------\r\n *\r\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\r\n *    ... bounce begins ...\r\n *    ... some time elapses ...\r\n *    ... physical touch during bounce ...\r\n * 2. `onMomentumScrollEnd`   (Makes no sense why this occurs first during bounce)\r\n * 3. `onTouchStartCapture`   (immediately after `onMomentumScrollEnd`)\r\n * 4. `onTouchStart`          (same, but bubble phase)\r\n * 5. `onTouchEnd`            (You could hold the touch start for a long time)\r\n * 6. `onMomentumScrollBegin` (When releasing the view starts bouncing back)\r\n *\r\n * So when we receive an `onTouchStart`, how can we tell if we are touching\r\n * *during* an animation (which then causes the animation to stop)? The only way\r\n * to tell is if the `touchStart` occurred immediately after the\r\n * `onMomentumScrollEnd`.\r\n *\r\n * This is abstracted out for you, so you can just call this.scrollResponderIsAnimating() if\r\n * necessary\r\n *\r\n * `ScrollResponder` also includes logic for blurring a currently focused input\r\n * if one is focused while scrolling. The `ScrollResponder` is a natural place\r\n * to put this logic since it can support not dismissing the keyboard while\r\n * scrolling, unless a recognized \"tap\"-like gesture has occurred.\r\n *\r\n * The public lifecycle API includes events for keyboard interaction, responder\r\n * interaction, and scrolling (among others). The keyboard callbacks\r\n * `onKeyboardWill/Did/*` are *global* events, but are invoked on scroll\r\n * responder's props so that you can guarantee that the scroll responder's\r\n * internal state has been updated accordingly (and deterministically) by\r\n * the time the props callbacks are invoke. Otherwise, you would always wonder\r\n * if the scroll responder is currently in a state where it recognizes new\r\n * keyboard positions etc. If coordinating scrolling with keyboard movement,\r\n * *always* use these hooks instead of listening to your own global keyboard\r\n * events.\r\n *\r\n * Public keyboard lifecycle API: (props callbacks)\r\n *\r\n * Standard Keyboard Appearance Sequence:\r\n *\r\n *   this.props.onKeyboardWillShow\r\n *   this.props.onKeyboardDidShow\r\n *\r\n * `onScrollResponderKeyboardDismissed` will be invoked if an appropriate\r\n * tap inside the scroll responder's scrollable region was responsible\r\n * for the dismissal of the keyboard. There are other reasons why the\r\n * keyboard could be dismissed.\r\n *\r\n *   this.props.onScrollResponderKeyboardDismissed\r\n *\r\n * Standard Keyboard Hide Sequence:\r\n *\r\n *   this.props.onKeyboardWillHide\r\n *   this.props.onKeyboardDidHide\r\n */\r\n\r\nvar emptyObject = {};\r\nvar IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;\r\nvar ScrollResponderMixin = {\r\n  // mixins: [Subscribable.Mixin],\r\n  scrollResponderMixinGetInitialState: function scrollResponderMixinGetInitialState() {\r\n    return {\r\n      isTouching: false,\r\n      lastMomentumScrollBeginTime: 0,\r\n      lastMomentumScrollEndTime: 0,\r\n      // Reset to false every time becomes responder. This is used to:\r\n      // - Determine if the scroll view has been scrolled and therefore should\r\n      // refuse to give up its responder lock.\r\n      // - Determine if releasing should dismiss the keyboard when we are in\r\n      // tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).\r\n      observedScrollSinceBecomingResponder: false,\r\n      becameResponderWhileAnimating: false\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Invoke this from an `onScroll` event.\r\n   */\r\n  scrollResponderHandleScrollShouldSetResponder: function scrollResponderHandleScrollShouldSetResponder() {\r\n    return this.state.isTouching;\r\n  },\r\n\r\n  /**\r\n   * Merely touch starting is not sufficient for a scroll view to become the\r\n   * responder. Being the \"responder\" means that the very next touch move/end\r\n   * event will result in an action/movement.\r\n   *\r\n   * Invoke this from an `onStartShouldSetResponder` event.\r\n   *\r\n   * `onStartShouldSetResponder` is used when the next move/end will trigger\r\n   * some UI movement/action, but when you want to yield priority to views\r\n   * nested inside of the view.\r\n   *\r\n   * There may be some cases where scroll views actually should return `true`\r\n   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap\r\n   * that gives priority to nested views.\r\n   *\r\n   * - If a single tap on the scroll view triggers an action such as\r\n   *   recentering a map style view yet wants to give priority to interaction\r\n   *   views inside (such as dropped pins or labels), then we would return true\r\n   *   from this method when there is a single touch.\r\n   *\r\n   * - Similar to the previous case, if a two finger \"tap\" should trigger a\r\n   *   zoom, we would check the `touches` count, and if `>= 2`, we would return\r\n   *   true.\r\n   *\r\n   */\r\n  scrollResponderHandleStartShouldSetResponder: function scrollResponderHandleStartShouldSetResponder() {\r\n    return false;\r\n  },\r\n\r\n  /**\r\n   * There are times when the scroll view wants to become the responder\r\n   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way\r\n   * that *doesn't* give priority to nested views (hence the capture phase):\r\n   *\r\n   * - Currently animating.\r\n   * - Tapping anywhere that is not the focused input, while the keyboard is\r\n   *   up (which should dismiss the keyboard).\r\n   *\r\n   * Invoke this from an `onStartShouldSetResponderCapture` event.\r\n   */\r\n  scrollResponderHandleStartShouldSetResponderCapture: function scrollResponderHandleStartShouldSetResponderCapture(e) {\r\n    // First see if we want to eat taps while the keyboard is up\r\n    // var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\r\n    // if (!this.props.keyboardShouldPersistTaps &&\r\n    //   currentlyFocusedTextInput != null &&\r\n    //   e.target !== currentlyFocusedTextInput) {\r\n    //   return true;\r\n    // }\r\n    return this.scrollResponderIsAnimating();\r\n  },\r\n\r\n  /**\r\n   * Invoke this from an `onResponderReject` event.\r\n   *\r\n   * Some other element is not yielding its role as responder. Normally, we'd\r\n   * just disable the `UIScrollView`, but a touch has already began on it, the\r\n   * `UIScrollView` will not accept being disabled after that. The easiest\r\n   * solution for now is to accept the limitation of disallowing this\r\n   * altogether. To improve this, find a way to disable the `UIScrollView` after\r\n   * a touch has already started.\r\n   */\r\n  scrollResponderHandleResponderReject: function scrollResponderHandleResponderReject() {\r\n    warning(false, \"ScrollView doesn't take rejection well - scrolls anyway\");\r\n  },\r\n\r\n  /**\r\n   * We will allow the scroll view to give up its lock iff it acquired the lock\r\n   * during an animation. This is a very useful default that happens to satisfy\r\n   * many common user experiences.\r\n   *\r\n   * - Stop a scroll on the left edge, then turn that into an outer view's\r\n   *   backswipe.\r\n   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer\r\n   *   view dismiss.\r\n   * - However, without catching the scroll view mid-bounce (while it is\r\n   *   motionless), if you drag far enough for the scroll view to become\r\n   *   responder (and therefore drag the scroll view a bit), any backswipe\r\n   *   navigation of a swipe gesture higher in the view hierarchy, should be\r\n   *   rejected.\r\n   */\r\n  scrollResponderHandleTerminationRequest: function scrollResponderHandleTerminationRequest() {\r\n    return !this.state.observedScrollSinceBecomingResponder;\r\n  },\r\n\r\n  /**\r\n   * Invoke this from an `onTouchEnd` event.\r\n   *\r\n   * @param {SyntheticEvent} e Event.\r\n   */\r\n  scrollResponderHandleTouchEnd: function scrollResponderHandleTouchEnd(e) {\r\n    var nativeEvent = e.nativeEvent;\r\n    this.state.isTouching = nativeEvent.touches.length !== 0;\r\n    this.props.onTouchEnd && this.props.onTouchEnd(e);\r\n  },\r\n\r\n  /**\r\n   * Invoke this from an `onResponderRelease` event.\r\n   */\r\n  scrollResponderHandleResponderRelease: function scrollResponderHandleResponderRelease(e) {\r\n    this.props.onResponderRelease && this.props.onResponderRelease(e); // By default scroll views will unfocus a textField\r\n    // if another touch occurs outside of it\r\n\r\n    var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\r\n\r\n    if (!this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && !this.state.observedScrollSinceBecomingResponder && !this.state.becameResponderWhileAnimating) {\r\n      this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);\r\n      TextInputState.blurTextInput(currentlyFocusedTextInput);\r\n    }\r\n  },\r\n  scrollResponderHandleScroll: function scrollResponderHandleScroll(e) {\r\n    this.state.observedScrollSinceBecomingResponder = true;\r\n    this.props.onScroll && this.props.onScroll(e);\r\n  },\r\n\r\n  /**\r\n   * Invoke this from an `onResponderGrant` event.\r\n   */\r\n  scrollResponderHandleResponderGrant: function scrollResponderHandleResponderGrant(e) {\r\n    this.state.observedScrollSinceBecomingResponder = false;\r\n    this.props.onResponderGrant && this.props.onResponderGrant(e);\r\n    this.state.becameResponderWhileAnimating = this.scrollResponderIsAnimating();\r\n  },\r\n\r\n  /**\r\n   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll\r\n   * animation, and there's not an easy way to distinguish a drag vs. stopping\r\n   * momentum.\r\n   *\r\n   * Invoke this from an `onScrollBeginDrag` event.\r\n   */\r\n  scrollResponderHandleScrollBeginDrag: function scrollResponderHandleScrollBeginDrag(e) {\r\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\r\n  },\r\n\r\n  /**\r\n   * Invoke this from an `onScrollEndDrag` event.\r\n   */\r\n  scrollResponderHandleScrollEndDrag: function scrollResponderHandleScrollEndDrag(e) {\r\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\r\n  },\r\n\r\n  /**\r\n   * Invoke this from an `onMomentumScrollBegin` event.\r\n   */\r\n  scrollResponderHandleMomentumScrollBegin: function scrollResponderHandleMomentumScrollBegin(e) {\r\n    this.state.lastMomentumScrollBeginTime = Date.now();\r\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\r\n  },\r\n\r\n  /**\r\n   * Invoke this from an `onMomentumScrollEnd` event.\r\n   */\r\n  scrollResponderHandleMomentumScrollEnd: function scrollResponderHandleMomentumScrollEnd(e) {\r\n    this.state.lastMomentumScrollEndTime = Date.now();\r\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\r\n  },\r\n\r\n  /**\r\n   * Invoke this from an `onTouchStart` event.\r\n   *\r\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\r\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\r\n   * permitted to be the responder (presumably because a contained view became\r\n   * responder). The `onResponderReject` won't fire in that case - it only\r\n   * fires when a *current* responder rejects our request.\r\n   *\r\n   * @param {SyntheticEvent} e Touch Start event.\r\n   */\r\n  scrollResponderHandleTouchStart: function scrollResponderHandleTouchStart(e) {\r\n    this.state.isTouching = true;\r\n    this.props.onTouchStart && this.props.onTouchStart(e);\r\n  },\r\n\r\n  /**\r\n   * Invoke this from an `onTouchMove` event.\r\n   *\r\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\r\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\r\n   * permitted to be the responder (presumably because a contained view became\r\n   * responder). The `onResponderReject` won't fire in that case - it only\r\n   * fires when a *current* responder rejects our request.\r\n   *\r\n   * @param {SyntheticEvent} e Touch Start event.\r\n   */\r\n  scrollResponderHandleTouchMove: function scrollResponderHandleTouchMove(e) {\r\n    this.props.onTouchMove && this.props.onTouchMove(e);\r\n  },\r\n\r\n  /**\r\n   * A helper function for this class that lets us quickly determine if the\r\n   * view is currently animating. This is particularly useful to know when\r\n   * a touch has just started or ended.\r\n   */\r\n  scrollResponderIsAnimating: function scrollResponderIsAnimating() {\r\n    var now = Date.now();\r\n    var timeSinceLastMomentumScrollEnd = now - this.state.lastMomentumScrollEndTime;\r\n    var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.state.lastMomentumScrollEndTime < this.state.lastMomentumScrollBeginTime;\r\n    return isAnimating;\r\n  },\r\n\r\n  /**\r\n   * Returns the node that represents native view that can be scrolled.\r\n   * Components can pass what node to use by defining a `getScrollableNode`\r\n   * function otherwise `this` is used.\r\n   */\r\n  scrollResponderGetScrollableNode: function scrollResponderGetScrollableNode() {\r\n    return this.getScrollableNode ? this.getScrollableNode() : findNodeHandle(this);\r\n  },\r\n\r\n  /**\r\n   * A helper function to scroll to a specific point in the scrollview.\r\n   * This is currently used to help focus on child textviews, but can also\r\n   * be used to quickly scroll to any element we want to focus. Syntax:\r\n   *\r\n   * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})\r\n   *\r\n   * Note: The weird argument signature is due to the fact that, for historical reasons,\r\n   * the function also accepts separate arguments as as alternative to the options object.\r\n   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.\r\n   */\r\n  scrollResponderScrollTo: function scrollResponderScrollTo(x, y, animated) {\r\n    if (typeof x === 'number') {\r\n      console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');\r\n    } else {\r\n      var _ref = x || emptyObject;\r\n\r\n      x = _ref.x;\r\n      y = _ref.y;\r\n      animated = _ref.animated;\r\n    }\r\n\r\n    var node = this.scrollResponderGetScrollableNode();\r\n    var left = x || 0;\r\n    var top = y || 0;\r\n\r\n    if (typeof node.scroll === 'function') {\r\n      node.scroll({\r\n        top: top,\r\n        left: left,\r\n        behavior: !animated ? 'auto' : 'smooth'\r\n      });\r\n    } else {\r\n      node.scrollLeft = left;\r\n      node.scrollTop = top;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * A helper function to zoom to a specific rect in the scrollview. The argument has the shape\r\n   * {x: number; y: number; width: number; height: number; animated: boolean = true}\r\n   *\r\n   * @platform ios\r\n   */\r\n  scrollResponderZoomTo: function scrollResponderZoomTo(rect, animated) // deprecated, put this inside the rect argument instead\r\n  {\r\n    if (Platform.OS !== 'ios') {\r\n      invariant('zoomToRect is not implemented');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Displays the scroll indicators momentarily.\r\n   */\r\n  scrollResponderFlashScrollIndicators: function scrollResponderFlashScrollIndicators() {},\r\n\r\n  /**\r\n   * This method should be used as the callback to onFocus in a TextInputs'\r\n   * parent view. Note that any module using this mixin needs to return\r\n   * the parent view's ref in getScrollViewRef() in order to use this method.\r\n   * @param {any} nodeHandle The TextInput node handle\r\n   * @param {number} additionalOffset The scroll view's top \"contentInset\".\r\n   *        Default is 0.\r\n   * @param {bool} preventNegativeScrolling Whether to allow pulling the content\r\n   *        down to make it meet the keyboard's top. Default is false.\r\n   */\r\n  scrollResponderScrollNativeHandleToKeyboard: function scrollResponderScrollNativeHandleToKeyboard(nodeHandle, additionalOffset, preventNegativeScrollOffset) {\r\n    this.additionalScrollOffset = additionalOffset || 0;\r\n    this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;\r\n    UIManager.measureLayout(nodeHandle, findNodeHandle(this.getInnerViewNode()), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);\r\n  },\r\n\r\n  /**\r\n   * The calculations performed here assume the scroll view takes up the entire\r\n   * screen - even if has some content inset. We then measure the offsets of the\r\n   * keyboard, and compensate both for the scroll view's \"contentInset\".\r\n   *\r\n   * @param {number} left Position of input w.r.t. table view.\r\n   * @param {number} top Position of input w.r.t. table view.\r\n   * @param {number} width Width of the text input.\r\n   * @param {number} height Height of the text input.\r\n   */\r\n  scrollResponderInputMeasureAndScrollToKeyboard: function scrollResponderInputMeasureAndScrollToKeyboard(left, top, width, height) {\r\n    var keyboardScreenY = Dimensions.get('window').height;\r\n\r\n    if (this.keyboardWillOpenTo) {\r\n      keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;\r\n    }\r\n\r\n    var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset; // By default, this can scroll with negative offset, pulling the content\r\n    // down so that the target component's bottom meets the keyboard's top.\r\n    // If requested otherwise, cap the offset at 0 minimum to avoid content\r\n    // shifting down.\r\n\r\n    if (this.preventNegativeScrollOffset) {\r\n      scrollOffsetY = Math.max(0, scrollOffsetY);\r\n    }\r\n\r\n    this.scrollResponderScrollTo({\r\n      x: 0,\r\n      y: scrollOffsetY,\r\n      animated: true\r\n    });\r\n    this.additionalOffset = 0;\r\n    this.preventNegativeScrollOffset = false;\r\n  },\r\n  scrollResponderTextInputFocusError: function scrollResponderTextInputFocusError(e) {\r\n    console.error('Error measuring text field: ', e);\r\n  },\r\n\r\n  /**\r\n   * `componentWillMount` is the closest thing to a  standard \"constructor\" for\r\n   * React components.\r\n   *\r\n   * The `keyboardWillShow` is called before input focus.\r\n   */\r\n  UNSAFE_componentWillMount: function UNSAFE_componentWillMount() {\r\n    this.keyboardWillOpenTo = null;\r\n    this.additionalScrollOffset = 0; // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardWillShow', this.scrollResponderKeyboardWillShow);\r\n    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardWillHide', this.scrollResponderKeyboardWillHide);\r\n    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardDidShow', this.scrollResponderKeyboardDidShow);\r\n    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardDidHide', this.scrollResponderKeyboardDidHide);\r\n  },\r\n\r\n  /**\r\n   * Warning, this may be called several times for a single keyboard opening.\r\n   * It's best to store the information in this method and then take any action\r\n   * at a later point (either in `keyboardDidShow` or other).\r\n   *\r\n   * Here's the order that events occur in:\r\n   * - focus\r\n   * - willShow {startCoordinates, endCoordinates} several times\r\n   * - didShow several times\r\n   * - blur\r\n   * - willHide {startCoordinates, endCoordinates} several times\r\n   * - didHide several times\r\n   *\r\n   * The `ScrollResponder` providesModule callbacks for each of these events.\r\n   * Even though any user could have easily listened to keyboard events\r\n   * themselves, using these `props` callbacks ensures that ordering of events\r\n   * is consistent - and not dependent on the order that the keyboard events are\r\n   * subscribed to. This matters when telling the scroll view to scroll to where\r\n   * the keyboard is headed - the scroll responder better have been notified of\r\n   * the keyboard destination before being instructed to scroll to where the\r\n   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything\r\n   * will work.\r\n   *\r\n   * WARNING: These callbacks will fire even if a keyboard is displayed in a\r\n   * different navigation pane. Filter out the events to determine if they are\r\n   * relevant to you. (For example, only if you receive these callbacks after\r\n   * you had explicitly focused a node etc).\r\n   */\r\n  scrollResponderKeyboardWillShow: function scrollResponderKeyboardWillShow(e) {\r\n    this.keyboardWillOpenTo = e;\r\n    this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);\r\n  },\r\n  scrollResponderKeyboardWillHide: function scrollResponderKeyboardWillHide(e) {\r\n    this.keyboardWillOpenTo = null;\r\n    this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);\r\n  },\r\n  scrollResponderKeyboardDidShow: function scrollResponderKeyboardDidShow(e) {\r\n    // TODO(7693961): The event for DidShow is not available on iOS yet.\r\n    // Use the one from WillShow and do not assign.\r\n    if (e) {\r\n      this.keyboardWillOpenTo = e;\r\n    }\r\n\r\n    this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);\r\n  },\r\n  scrollResponderKeyboardDidHide: function scrollResponderKeyboardDidHide(e) {\r\n    this.keyboardWillOpenTo = null;\r\n    this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);\r\n  }\r\n};\r\nvar ScrollResponder = {\r\n  Mixin: ScrollResponderMixin\r\n};\r\nexport default ScrollResponder;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}