{"ast":null,"code":"'use strict';\n\nvar BatchedBridge = require(\"../../BatchedBridge/BatchedBridge\");\n\nvar Platform = require(\"../../Utilities/Platform\");\n\nvar Systrace = require(\"../../Performance/Systrace\");\n\nvar invariant = require('invariant');\n\nimport NativeTiming from \"./NativeTiming\";\nvar FRAME_DURATION = 1000 / 60;\nvar IDLE_CALLBACK_FRAME_DEADLINE = 1;\nvar MAX_TIMER_DURATION_MS = 60 * 1000;\nvar IS_ANDROID = Platform.OS === 'android';\nvar ANDROID_LONG_TIMER_MESSAGE = 'Setting a timer for a long period of time, i.e. multiple minutes, is a ' + 'performance and correctness issue on Android as it keeps the timer ' + 'module awake, and timers can only be called when the app is in the foreground. ' + 'See https://github.com/facebook/react-native/issues/12981 for more info.';\nvar callbacks = [];\nvar types = [];\nvar timerIDs = [];\nvar immediates = [];\nvar requestIdleCallbacks = [];\nvar requestIdleCallbackTimeouts = {};\nvar GUID = 1;\nvar errors = null;\nvar hasEmittedTimeDriftWarning = false;\n\nfunction _getFreeIndex() {\n  var freeIndex = timerIDs.indexOf(null);\n\n  if (freeIndex === -1) {\n    freeIndex = timerIDs.length;\n  }\n\n  return freeIndex;\n}\n\nfunction _allocateCallback(func, type) {\n  var id = GUID++;\n\n  var freeIndex = _getFreeIndex();\n\n  timerIDs[freeIndex] = id;\n  callbacks[freeIndex] = func;\n  types[freeIndex] = type;\n  return id;\n}\n\nfunction _callTimer(timerID, frameTime, didTimeout) {\n  if (timerID > GUID) {\n    console.warn('Tried to call timer with ID %s but no such timer exists.', timerID);\n  }\n\n  var timerIndex = timerIDs.indexOf(timerID);\n\n  if (timerIndex === -1) {\n    return;\n  }\n\n  var type = types[timerIndex];\n  var callback = callbacks[timerIndex];\n\n  if (!callback || !type) {\n    console.error('No callback found for timerID ' + timerID);\n    return;\n  }\n\n  if (__DEV__) {\n    Systrace.beginEvent(type + ' [invoke]');\n  }\n\n  if (type !== 'setInterval') {\n    _clearIndex(timerIndex);\n  }\n\n  try {\n    if (type === 'setTimeout' || type === 'setInterval' || type === 'setImmediate') {\n      callback();\n    } else if (type === 'requestAnimationFrame') {\n      callback(global.performance.now());\n    } else if (type === 'requestIdleCallback') {\n      callback({\n        timeRemaining: function timeRemaining() {\n          return Math.max(0, FRAME_DURATION - (global.performance.now() - frameTime));\n        },\n        didTimeout: !!didTimeout\n      });\n    } else {\n      console.error('Tried to call a callback with invalid type: ' + type);\n    }\n  } catch (e) {\n    if (!errors) {\n      errors = [e];\n    } else {\n      errors.push(e);\n    }\n  }\n\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n}\n\nfunction _callImmediatesPass() {\n  if (immediates.length === 0) {\n    return false;\n  }\n\n  if (__DEV__) {\n    Systrace.beginEvent('callImmediatesPass()');\n  }\n\n  var passImmediates = immediates;\n  immediates = [];\n\n  for (var i = 0; i < passImmediates.length; ++i) {\n    _callTimer(passImmediates[i], 0);\n  }\n\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n\n  return immediates.length > 0;\n}\n\nfunction _clearIndex(i) {\n  timerIDs[i] = null;\n  callbacks[i] = null;\n  types[i] = null;\n}\n\nfunction _freeCallback(timerID) {\n  if (timerID == null) {\n    return;\n  }\n\n  var index = timerIDs.indexOf(timerID);\n\n  if (index !== -1) {\n    var type = types[index];\n\n    _clearIndex(index);\n\n    if (type !== 'setImmediate' && type !== 'requestIdleCallback') {\n      deleteTimer(timerID);\n    }\n  }\n}\n\nvar JSTimers = {\n  setTimeout: function setTimeout(func, duration) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {\n      console.warn(ANDROID_LONG_TIMER_MESSAGE + '\\n' + '(Saw setTimeout with duration ' + duration + 'ms)');\n    }\n\n    var id = _allocateCallback(function () {\n      return func.apply(undefined, args);\n    }, 'setTimeout');\n\n    createTimer(id, duration || 0, Date.now(), false);\n    return id;\n  },\n  setInterval: function setInterval(func, duration) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n\n    if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {\n      console.warn(ANDROID_LONG_TIMER_MESSAGE + '\\n' + '(Saw setInterval with duration ' + duration + 'ms)');\n    }\n\n    var id = _allocateCallback(function () {\n      return func.apply(undefined, args);\n    }, 'setInterval');\n\n    createTimer(id, duration || 0, Date.now(), true);\n    return id;\n  },\n  setImmediate: function setImmediate(func) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    var id = _allocateCallback(function () {\n      return func.apply(undefined, args);\n    }, 'setImmediate');\n\n    immediates.push(id);\n    return id;\n  },\n  requestAnimationFrame: function requestAnimationFrame(func) {\n    var id = _allocateCallback(func, 'requestAnimationFrame');\n\n    createTimer(id, 1, Date.now(), false);\n    return id;\n  },\n  requestIdleCallback: function requestIdleCallback(func, options) {\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(true);\n    }\n\n    var timeout = options && options.timeout;\n\n    var id = _allocateCallback(timeout != null ? function (deadline) {\n      var timeoutId = requestIdleCallbackTimeouts[id];\n\n      if (timeoutId) {\n        JSTimers.clearTimeout(timeoutId);\n        delete requestIdleCallbackTimeouts[id];\n      }\n\n      return func(deadline);\n    } : func, 'requestIdleCallback');\n\n    requestIdleCallbacks.push(id);\n\n    if (timeout != null) {\n      var timeoutId = JSTimers.setTimeout(function () {\n        var index = requestIdleCallbacks.indexOf(id);\n\n        if (index > -1) {\n          requestIdleCallbacks.splice(index, 1);\n\n          _callTimer(id, global.performance.now(), true);\n        }\n\n        delete requestIdleCallbackTimeouts[id];\n\n        if (requestIdleCallbacks.length === 0) {\n          setSendIdleEvents(false);\n        }\n      }, timeout);\n      requestIdleCallbackTimeouts[id] = timeoutId;\n    }\n\n    return id;\n  },\n  cancelIdleCallback: function cancelIdleCallback(timerID) {\n    _freeCallback(timerID);\n\n    var index = requestIdleCallbacks.indexOf(timerID);\n\n    if (index !== -1) {\n      requestIdleCallbacks.splice(index, 1);\n    }\n\n    var timeoutId = requestIdleCallbackTimeouts[timerID];\n\n    if (timeoutId) {\n      JSTimers.clearTimeout(timeoutId);\n      delete requestIdleCallbackTimeouts[timerID];\n    }\n\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(false);\n    }\n  },\n  clearTimeout: function clearTimeout(timerID) {\n    _freeCallback(timerID);\n  },\n  clearInterval: function clearInterval(timerID) {\n    _freeCallback(timerID);\n  },\n  clearImmediate: function clearImmediate(timerID) {\n    _freeCallback(timerID);\n\n    var index = immediates.indexOf(timerID);\n\n    if (index !== -1) {\n      immediates.splice(index, 1);\n    }\n  },\n  cancelAnimationFrame: function cancelAnimationFrame(timerID) {\n    _freeCallback(timerID);\n  },\n  callTimers: function callTimers(timersToCall) {\n    invariant(timersToCall.length !== 0, 'Cannot call `callTimers` with an empty list of IDs.');\n    errors = null;\n\n    for (var i = 0; i < timersToCall.length; i++) {\n      _callTimer(timersToCall[i], 0);\n    }\n\n    if (errors) {\n      var errorCount = errors.length;\n\n      if (errorCount > 1) {\n        for (var ii = 1; ii < errorCount; ii++) {\n          JSTimers.setTimeout(function (error) {\n            throw error;\n          }.bind(null, errors[ii]), 0);\n        }\n      }\n\n      throw errors[0];\n    }\n  },\n  callIdleCallbacks: function callIdleCallbacks(frameTime) {\n    if (FRAME_DURATION - (global.performance.now() - frameTime) < IDLE_CALLBACK_FRAME_DEADLINE) {\n      return;\n    }\n\n    errors = null;\n\n    if (requestIdleCallbacks.length > 0) {\n      var passIdleCallbacks = requestIdleCallbacks;\n      requestIdleCallbacks = [];\n\n      for (var i = 0; i < passIdleCallbacks.length; ++i) {\n        _callTimer(passIdleCallbacks[i], frameTime);\n      }\n    }\n\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(false);\n    }\n\n    if (errors) {\n      errors.forEach(function (error) {\n        return JSTimers.setTimeout(function () {\n          throw error;\n        }, 0);\n      });\n    }\n  },\n  callImmediates: function callImmediates() {\n    errors = null;\n\n    while (_callImmediatesPass()) {}\n\n    if (errors) {\n      errors.forEach(function (error) {\n        return JSTimers.setTimeout(function () {\n          throw error;\n        }, 0);\n      });\n    }\n  },\n  emitTimeDriftWarning: function emitTimeDriftWarning(warningMessage) {\n    if (hasEmittedTimeDriftWarning) {\n      return;\n    }\n\n    hasEmittedTimeDriftWarning = true;\n    console.warn(warningMessage);\n  }\n};\n\nfunction createTimer(callbackID, duration, jsSchedulingTime, repeats) {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.createTimer(callbackID, duration, jsSchedulingTime, repeats);\n}\n\nfunction deleteTimer(timerID) {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.deleteTimer(timerID);\n}\n\nfunction setSendIdleEvents(sendIdleEvents) {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.setSendIdleEvents(sendIdleEvents);\n}\n\nvar ExportedJSTimers;\n\nif (!NativeTiming) {\n  console.warn(\"Timing native module is not available, can't set timers.\");\n  ExportedJSTimers = {\n    callImmediates: JSTimers.callImmediates,\n    setImmediate: JSTimers.setImmediate\n  };\n} else {\n  ExportedJSTimers = JSTimers;\n}\n\nBatchedBridge.setImmediatesCallback(JSTimers.callImmediates);\nmodule.exports = ExportedJSTimers;","map":{"version":3,"sources":["D:/khaled/Matriels/Third Year/Second term/CS303/CS303-Project-1/node_modules/react-native/Libraries/Core/Timers/JSTimers.js"],"names":["BatchedBridge","require","Platform","Systrace","invariant","NativeTiming","FRAME_DURATION","IDLE_CALLBACK_FRAME_DEADLINE","MAX_TIMER_DURATION_MS","IS_ANDROID","OS","ANDROID_LONG_TIMER_MESSAGE","callbacks","types","timerIDs","immediates","requestIdleCallbacks","requestIdleCallbackTimeouts","GUID","errors","hasEmittedTimeDriftWarning","_getFreeIndex","freeIndex","indexOf","length","_allocateCallback","func","type","id","_callTimer","timerID","frameTime","didTimeout","console","warn","timerIndex","callback","error","__DEV__","beginEvent","_clearIndex","global","performance","now","timeRemaining","Math","max","e","push","endEvent","_callImmediatesPass","passImmediates","i","_freeCallback","index","deleteTimer","JSTimers","setTimeout","duration","args","apply","undefined","createTimer","Date","setInterval","setImmediate","requestAnimationFrame","requestIdleCallback","options","setSendIdleEvents","timeout","deadline","timeoutId","clearTimeout","splice","cancelIdleCallback","clearInterval","clearImmediate","cancelAnimationFrame","callTimers","timersToCall","errorCount","ii","bind","callIdleCallbacks","passIdleCallbacks","forEach","callImmediates","emitTimeDriftWarning","warningMessage","callbackID","jsSchedulingTime","repeats","sendIdleEvents","ExportedJSTimers","setImmediatesCallback","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * @flow\r\n */\r\n\r\n'use strict';\r\n\r\nconst BatchedBridge = require('../../BatchedBridge/BatchedBridge');\r\nconst Platform = require('../../Utilities/Platform');\r\nconst Systrace = require('../../Performance/Systrace');\r\n\r\nconst invariant = require('invariant');\r\n\r\nimport NativeTiming from './NativeTiming';\r\n\r\n/**\r\n * JS implementation of timer functions. Must be completely driven by an\r\n * external clock signal, all that's stored here is timerID, timer type, and\r\n * callback.\r\n */\r\n\r\nexport type JSTimerType =\r\n  | 'setTimeout'\r\n  | 'setInterval'\r\n  | 'requestAnimationFrame'\r\n  | 'setImmediate'\r\n  | 'requestIdleCallback';\r\n\r\n// These timing constants should be kept in sync with the ones in native ios and\r\n// android `RCTTiming` module.\r\nconst FRAME_DURATION = 1000 / 60;\r\nconst IDLE_CALLBACK_FRAME_DEADLINE = 1;\r\n\r\nconst MAX_TIMER_DURATION_MS = 60 * 1000;\r\nconst IS_ANDROID = Platform.OS === 'android';\r\nconst ANDROID_LONG_TIMER_MESSAGE =\r\n  'Setting a timer for a long period of time, i.e. multiple minutes, is a ' +\r\n  'performance and correctness issue on Android as it keeps the timer ' +\r\n  'module awake, and timers can only be called when the app is in the foreground. ' +\r\n  'See https://github.com/facebook/react-native/issues/12981 for more info.';\r\n\r\n// Parallel arrays\r\nconst callbacks: Array<?Function> = [];\r\nconst types: Array<?JSTimerType> = [];\r\nconst timerIDs: Array<?number> = [];\r\nlet immediates: Array<number> = [];\r\nlet requestIdleCallbacks: Array<number> = [];\r\nconst requestIdleCallbackTimeouts: {[number]: number, ...} = {};\r\n\r\nlet GUID = 1;\r\nlet errors: ?Array<Error> = null;\r\n\r\nlet hasEmittedTimeDriftWarning = false;\r\n\r\n// Returns a free index if one is available, and the next consecutive index otherwise.\r\nfunction _getFreeIndex(): number {\r\n  let freeIndex = timerIDs.indexOf(null);\r\n  if (freeIndex === -1) {\r\n    freeIndex = timerIDs.length;\r\n  }\r\n  return freeIndex;\r\n}\r\n\r\nfunction _allocateCallback(func: Function, type: JSTimerType): number {\r\n  const id = GUID++;\r\n  const freeIndex = _getFreeIndex();\r\n  timerIDs[freeIndex] = id;\r\n  callbacks[freeIndex] = func;\r\n  types[freeIndex] = type;\r\n  return id;\r\n}\r\n\r\n/**\r\n * Calls the callback associated with the ID. Also unregister that callback\r\n * if it was a one time timer (setTimeout), and not unregister it if it was\r\n * recurring (setInterval).\r\n */\r\nfunction _callTimer(timerID: number, frameTime: number, didTimeout: ?boolean) {\r\n  if (timerID > GUID) {\r\n    console.warn(\r\n      'Tried to call timer with ID %s but no such timer exists.',\r\n      timerID,\r\n    );\r\n  }\r\n\r\n  // timerIndex of -1 means that no timer with that ID exists. There are\r\n  // two situations when this happens, when a garbage timer ID was given\r\n  // and when a previously existing timer was deleted before this callback\r\n  // fired. In both cases we want to ignore the timer id, but in the former\r\n  // case we warn as well.\r\n  const timerIndex = timerIDs.indexOf(timerID);\r\n  if (timerIndex === -1) {\r\n    return;\r\n  }\r\n\r\n  const type = types[timerIndex];\r\n  const callback = callbacks[timerIndex];\r\n  if (!callback || !type) {\r\n    console.error('No callback found for timerID ' + timerID);\r\n    return;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    Systrace.beginEvent(type + ' [invoke]');\r\n  }\r\n\r\n  // Clear the metadata\r\n  if (type !== 'setInterval') {\r\n    _clearIndex(timerIndex);\r\n  }\r\n\r\n  try {\r\n    if (\r\n      type === 'setTimeout' ||\r\n      type === 'setInterval' ||\r\n      type === 'setImmediate'\r\n    ) {\r\n      callback();\r\n    } else if (type === 'requestAnimationFrame') {\r\n      callback(global.performance.now());\r\n    } else if (type === 'requestIdleCallback') {\r\n      callback({\r\n        timeRemaining: function() {\r\n          // TODO: Optimisation: allow running for longer than one frame if\r\n          // there are no pending JS calls on the bridge from native. This\r\n          // would require a way to check the bridge queue synchronously.\r\n          return Math.max(\r\n            0,\r\n            FRAME_DURATION - (global.performance.now() - frameTime),\r\n          );\r\n        },\r\n        didTimeout: !!didTimeout,\r\n      });\r\n    } else {\r\n      console.error('Tried to call a callback with invalid type: ' + type);\r\n    }\r\n  } catch (e) {\r\n    // Don't rethrow so that we can run all timers.\r\n    if (!errors) {\r\n      errors = [e];\r\n    } else {\r\n      errors.push(e);\r\n    }\r\n  }\r\n\r\n  if (__DEV__) {\r\n    Systrace.endEvent();\r\n  }\r\n}\r\n\r\n/**\r\n * Performs a single pass over the enqueued immediates. Returns whether\r\n * more immediates are queued up (can be used as a condition a while loop).\r\n */\r\nfunction _callImmediatesPass() {\r\n  if (immediates.length === 0) {\r\n    return false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    Systrace.beginEvent('callImmediatesPass()');\r\n  }\r\n\r\n  // The main reason to extract a single pass is so that we can track\r\n  // in the system trace\r\n  const passImmediates = immediates;\r\n  immediates = [];\r\n\r\n  // Use for loop rather than forEach as per @vjeux's advice\r\n  // https://github.com/facebook/react-native/commit/c8fd9f7588ad02d2293cac7224715f4af7b0f352#commitcomment-14570051\r\n  for (let i = 0; i < passImmediates.length; ++i) {\r\n    _callTimer(passImmediates[i], 0);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    Systrace.endEvent();\r\n  }\r\n  return immediates.length > 0;\r\n}\r\n\r\nfunction _clearIndex(i: number) {\r\n  timerIDs[i] = null;\r\n  callbacks[i] = null;\r\n  types[i] = null;\r\n}\r\n\r\nfunction _freeCallback(timerID: number) {\r\n  // timerIDs contains nulls after timers have been removed;\r\n  // ignore nulls upfront so indexOf doesn't find them\r\n  if (timerID == null) {\r\n    return;\r\n  }\r\n\r\n  const index = timerIDs.indexOf(timerID);\r\n  // See corresponding comment in `callTimers` for reasoning behind this\r\n  if (index !== -1) {\r\n    const type = types[index];\r\n    _clearIndex(index);\r\n    if (type !== 'setImmediate' && type !== 'requestIdleCallback') {\r\n      deleteTimer(timerID);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * JS implementation of timer functions. Must be completely driven by an\r\n * external clock signal, all that's stored here is timerID, timer type, and\r\n * callback.\r\n */\r\nconst JSTimers = {\r\n  /**\r\n   * @param {function} func Callback to be invoked after `duration` ms.\r\n   * @param {number} duration Number of milliseconds.\r\n   */\r\n  setTimeout: function(func: Function, duration: number, ...args: any): number {\r\n    if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {\r\n      console.warn(\r\n        ANDROID_LONG_TIMER_MESSAGE +\r\n          '\\n' +\r\n          '(Saw setTimeout with duration ' +\r\n          duration +\r\n          'ms)',\r\n      );\r\n    }\r\n    const id = _allocateCallback(\r\n      () => func.apply(undefined, args),\r\n      'setTimeout',\r\n    );\r\n    createTimer(id, duration || 0, Date.now(), /* recurring */ false);\r\n    return id;\r\n  },\r\n\r\n  /**\r\n   * @param {function} func Callback to be invoked every `duration` ms.\r\n   * @param {number} duration Number of milliseconds.\r\n   */\r\n  setInterval: function(\r\n    func: Function,\r\n    duration: number,\r\n    ...args: any\r\n  ): number {\r\n    if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {\r\n      console.warn(\r\n        ANDROID_LONG_TIMER_MESSAGE +\r\n          '\\n' +\r\n          '(Saw setInterval with duration ' +\r\n          duration +\r\n          'ms)',\r\n      );\r\n    }\r\n    const id = _allocateCallback(\r\n      () => func.apply(undefined, args),\r\n      'setInterval',\r\n    );\r\n    createTimer(id, duration || 0, Date.now(), /* recurring */ true);\r\n    return id;\r\n  },\r\n\r\n  /**\r\n   * @param {function} func Callback to be invoked before the end of the\r\n   * current JavaScript execution loop.\r\n   */\r\n  setImmediate: function(func: Function, ...args: any) {\r\n    const id = _allocateCallback(\r\n      () => func.apply(undefined, args),\r\n      'setImmediate',\r\n    );\r\n    immediates.push(id);\r\n    return id;\r\n  },\r\n\r\n  /**\r\n   * @param {function} func Callback to be invoked every frame.\r\n   */\r\n  requestAnimationFrame: function(func: Function) {\r\n    const id = _allocateCallback(func, 'requestAnimationFrame');\r\n    createTimer(id, 1, Date.now(), /* recurring */ false);\r\n    return id;\r\n  },\r\n\r\n  /**\r\n   * @param {function} func Callback to be invoked every frame and provided\r\n   * with time remaining in frame.\r\n   * @param {?object} options\r\n   */\r\n  requestIdleCallback: function(func: Function, options: ?Object) {\r\n    if (requestIdleCallbacks.length === 0) {\r\n      setSendIdleEvents(true);\r\n    }\r\n\r\n    const timeout = options && options.timeout;\r\n    const id = _allocateCallback(\r\n      timeout != null\r\n        ? deadline => {\r\n            const timeoutId = requestIdleCallbackTimeouts[id];\r\n            if (timeoutId) {\r\n              JSTimers.clearTimeout(timeoutId);\r\n              delete requestIdleCallbackTimeouts[id];\r\n            }\r\n            return func(deadline);\r\n          }\r\n        : func,\r\n      'requestIdleCallback',\r\n    );\r\n    requestIdleCallbacks.push(id);\r\n\r\n    if (timeout != null) {\r\n      const timeoutId = JSTimers.setTimeout(() => {\r\n        const index = requestIdleCallbacks.indexOf(id);\r\n        if (index > -1) {\r\n          requestIdleCallbacks.splice(index, 1);\r\n          _callTimer(id, global.performance.now(), true);\r\n        }\r\n        delete requestIdleCallbackTimeouts[id];\r\n        if (requestIdleCallbacks.length === 0) {\r\n          setSendIdleEvents(false);\r\n        }\r\n      }, timeout);\r\n      requestIdleCallbackTimeouts[id] = timeoutId;\r\n    }\r\n    return id;\r\n  },\r\n\r\n  cancelIdleCallback: function(timerID: number) {\r\n    _freeCallback(timerID);\r\n    const index = requestIdleCallbacks.indexOf(timerID);\r\n    if (index !== -1) {\r\n      requestIdleCallbacks.splice(index, 1);\r\n    }\r\n\r\n    const timeoutId = requestIdleCallbackTimeouts[timerID];\r\n    if (timeoutId) {\r\n      JSTimers.clearTimeout(timeoutId);\r\n      delete requestIdleCallbackTimeouts[timerID];\r\n    }\r\n\r\n    if (requestIdleCallbacks.length === 0) {\r\n      setSendIdleEvents(false);\r\n    }\r\n  },\r\n\r\n  clearTimeout: function(timerID: number) {\r\n    _freeCallback(timerID);\r\n  },\r\n\r\n  clearInterval: function(timerID: number) {\r\n    _freeCallback(timerID);\r\n  },\r\n\r\n  clearImmediate: function(timerID: number) {\r\n    _freeCallback(timerID);\r\n    const index = immediates.indexOf(timerID);\r\n    if (index !== -1) {\r\n      immediates.splice(index, 1);\r\n    }\r\n  },\r\n\r\n  cancelAnimationFrame: function(timerID: number) {\r\n    _freeCallback(timerID);\r\n  },\r\n\r\n  /**\r\n   * This is called from the native side. We are passed an array of timerIDs,\r\n   * and\r\n   */\r\n  callTimers: function(timersToCall: Array<number>) {\r\n    invariant(\r\n      timersToCall.length !== 0,\r\n      'Cannot call `callTimers` with an empty list of IDs.',\r\n    );\r\n\r\n    errors = (null: ?Array<Error>);\r\n    for (let i = 0; i < timersToCall.length; i++) {\r\n      _callTimer(timersToCall[i], 0);\r\n    }\r\n\r\n    if (errors) {\r\n      const errorCount = errors.length;\r\n      if (errorCount > 1) {\r\n        // Throw all the other errors in a setTimeout, which will throw each\r\n        // error one at a time\r\n        for (let ii = 1; ii < errorCount; ii++) {\r\n          JSTimers.setTimeout(\r\n            (error => {\r\n              throw error;\r\n            }).bind(null, errors[ii]),\r\n            0,\r\n          );\r\n        }\r\n      }\r\n      throw errors[0];\r\n    }\r\n  },\r\n\r\n  callIdleCallbacks: function(frameTime: number) {\r\n    if (\r\n      FRAME_DURATION - (global.performance.now() - frameTime) <\r\n      IDLE_CALLBACK_FRAME_DEADLINE\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    errors = (null: ?Array<Error>);\r\n    if (requestIdleCallbacks.length > 0) {\r\n      const passIdleCallbacks = requestIdleCallbacks;\r\n      requestIdleCallbacks = [];\r\n\r\n      for (let i = 0; i < passIdleCallbacks.length; ++i) {\r\n        _callTimer(passIdleCallbacks[i], frameTime);\r\n      }\r\n    }\r\n\r\n    if (requestIdleCallbacks.length === 0) {\r\n      setSendIdleEvents(false);\r\n    }\r\n\r\n    if (errors) {\r\n      errors.forEach(error =>\r\n        JSTimers.setTimeout(() => {\r\n          throw error;\r\n        }, 0),\r\n      );\r\n    }\r\n  },\r\n\r\n  /**\r\n   * This is called after we execute any command we receive from native but\r\n   * before we hand control back to native.\r\n   */\r\n  callImmediates() {\r\n    errors = (null: ?Array<Error>);\r\n    while (_callImmediatesPass()) {}\r\n    if (errors) {\r\n      errors.forEach(error =>\r\n        JSTimers.setTimeout(() => {\r\n          throw error;\r\n        }, 0),\r\n      );\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Called from native (in development) when environment times are out-of-sync.\r\n   */\r\n  emitTimeDriftWarning(warningMessage: string) {\r\n    if (hasEmittedTimeDriftWarning) {\r\n      return;\r\n    }\r\n    hasEmittedTimeDriftWarning = true;\r\n    console.warn(warningMessage);\r\n  },\r\n};\r\n\r\nfunction createTimer(\r\n  callbackID: number,\r\n  duration: number,\r\n  jsSchedulingTime: number,\r\n  repeats: boolean,\r\n): void {\r\n  invariant(NativeTiming, 'NativeTiming is available');\r\n  NativeTiming.createTimer(callbackID, duration, jsSchedulingTime, repeats);\r\n}\r\n\r\nfunction deleteTimer(timerID: number): void {\r\n  invariant(NativeTiming, 'NativeTiming is available');\r\n  NativeTiming.deleteTimer(timerID);\r\n}\r\n\r\nfunction setSendIdleEvents(sendIdleEvents: boolean): void {\r\n  invariant(NativeTiming, 'NativeTiming is available');\r\n  NativeTiming.setSendIdleEvents(sendIdleEvents);\r\n}\r\n\r\nlet ExportedJSTimers: {|\r\n  callIdleCallbacks: (frameTime: number) => any | void,\r\n  callImmediates: () => void,\r\n  callTimers: (timersToCall: Array<number>) => any | void,\r\n  cancelAnimationFrame: (timerID: number) => void,\r\n  cancelIdleCallback: (timerID: number) => void,\r\n  clearImmediate: (timerID: number) => void,\r\n  clearInterval: (timerID: number) => void,\r\n  clearTimeout: (timerID: number) => void,\r\n  emitTimeDriftWarning: (warningMessage: string) => any | void,\r\n  requestAnimationFrame: (func: any) => any | number,\r\n  requestIdleCallback: (func: any, options: ?any) => any | number,\r\n  setImmediate: (func: any, ...args: any) => number,\r\n  setInterval: (func: any, duration: number, ...args: any) => number,\r\n  setTimeout: (func: any, duration: number, ...args: any) => number,\r\n|};\r\n\r\nif (!NativeTiming) {\r\n  console.warn(\"Timing native module is not available, can't set timers.\");\r\n  // $FlowFixMe: we can assume timers are generally available\r\n  ExportedJSTimers = ({\r\n    callImmediates: JSTimers.callImmediates,\r\n    setImmediate: JSTimers.setImmediate,\r\n  }: typeof JSTimers);\r\n} else {\r\n  ExportedJSTimers = JSTimers;\r\n}\r\n\r\nBatchedBridge.setImmediatesCallback(JSTimers.callImmediates);\r\n\r\nmodule.exports = ExportedJSTimers;\r\n"]},"metadata":{},"sourceType":"module"}