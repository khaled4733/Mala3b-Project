{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport NativeEventEmitter from \"../EventEmitter/NativeEventEmitter\";\nimport logError from \"../Utilities/logError\";\nimport EventEmitter from \"../vendor/emitter/EventEmitter\";\nimport NativeAppState from \"./NativeAppState\";\nimport invariant from 'invariant';\n\nvar AppState = function (_NativeEventEmitter) {\n  _inherits(AppState, _NativeEventEmitter);\n\n  var _super = _createSuper(AppState);\n\n  function AppState() {\n    var _this;\n\n    _classCallCheck(this, AppState);\n\n    _this = _super.call(this, NativeAppState);\n    _this._supportedEvents = ['change', 'memoryWarning', 'blur', 'focus'];\n    _this.isAvailable = true;\n    _this._eventHandlers = _this._supportedEvents.reduce(function (handlers, key) {\n      handlers[key] = new Map();\n      return handlers;\n    }, {});\n    _this.currentState = NativeAppState.getConstants().initialAppState;\n    var eventUpdated = false;\n\n    _this.addListener('appStateDidChange', function (appStateData) {\n      eventUpdated = true;\n      _this.currentState = appStateData.app_state;\n    });\n\n    NativeAppState.getCurrentAppState(function (appStateData) {\n      if (!eventUpdated && _this.currentState !== appStateData.app_state) {\n        _this.currentState = appStateData.app_state;\n\n        _this.emit('appStateDidChange', appStateData);\n      }\n    }, logError);\n    return _this;\n  }\n\n  _createClass(AppState, [{\n    key: \"addEventListener\",\n    value: function addEventListener(type, handler) {\n      invariant(this._supportedEvents.indexOf(type) !== -1, 'Trying to subscribe to unknown event: \"%s\"', type);\n\n      switch (type) {\n        case 'change':\n          {\n            this._eventHandlers[type].set(handler, this.addListener('appStateDidChange', function (appStateData) {\n              handler(appStateData.app_state);\n            }));\n\n            break;\n          }\n\n        case 'memoryWarning':\n          {\n            this._eventHandlers[type].set(handler, this.addListener('memoryWarning', handler));\n\n            break;\n          }\n\n        case 'blur':\n        case 'focus':\n          {\n            this._eventHandlers[type].set(handler, this.addListener('appStateFocusChange', function (hasFocus) {\n              if (type === 'blur' && !hasFocus) {\n                handler();\n              }\n\n              if (type === 'focus' && hasFocus) {\n                handler();\n              }\n            }));\n          }\n      }\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type, handler) {\n      invariant(this._supportedEvents.indexOf(type) !== -1, 'Trying to remove listener for unknown event: \"%s\"', type);\n\n      if (!this._eventHandlers[type].has(handler)) {\n        return;\n      }\n\n      this._eventHandlers[type].get(handler).remove();\n\n      this._eventHandlers[type].delete(handler);\n    }\n  }]);\n\n  return AppState;\n}(NativeEventEmitter);\n\nfunction throwMissingNativeModule() {\n  invariant(false, 'Cannot use AppState module when native RCTAppState is not included in the build.\\n' + 'Either include it, or check AppState.isAvailable before calling any methods.');\n}\n\nvar MissingNativeAppStateShim = function (_EventEmitter) {\n  _inherits(MissingNativeAppStateShim, _EventEmitter);\n\n  var _super2 = _createSuper(MissingNativeAppStateShim);\n\n  function MissingNativeAppStateShim() {\n    var _this2;\n\n    _classCallCheck(this, MissingNativeAppStateShim);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this2 = _super2.call.apply(_super2, [this].concat(args));\n    _this2.isAvailable = false;\n    _this2.currentState = null;\n    return _this2;\n  }\n\n  _createClass(MissingNativeAppStateShim, [{\n    key: \"addEventListener\",\n    value: function addEventListener(type, handler) {\n      throwMissingNativeModule();\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type, handler) {\n      throwMissingNativeModule();\n    }\n  }, {\n    key: \"addListener\",\n    value: function addListener() {\n      throwMissingNativeModule();\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners() {\n      throwMissingNativeModule();\n    }\n  }, {\n    key: \"removeSubscription\",\n    value: function removeSubscription() {\n      throwMissingNativeModule();\n    }\n  }]);\n\n  return MissingNativeAppStateShim;\n}(EventEmitter);\n\nvar AppStateInstance = NativeAppState ? new AppState() : new MissingNativeAppStateShim();\nmodule.exports = AppStateInstance;","map":{"version":3,"sources":["D:/khaled/Matriels/Third Year/Second term/CS303/CS303-Project-1/node_modules/react-native/Libraries/AppState/AppState.js"],"names":["NativeEventEmitter","logError","EventEmitter","NativeAppState","invariant","AppState","_supportedEvents","isAvailable","_eventHandlers","reduce","handlers","key","Map","currentState","getConstants","initialAppState","eventUpdated","addListener","appStateData","app_state","getCurrentAppState","emit","type","handler","indexOf","set","hasFocus","has","get","remove","delete","throwMissingNativeModule","MissingNativeAppStateShim","AppStateInstance","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * @flow\r\n */\r\n\r\n'use strict';\r\n\r\nimport NativeEventEmitter from '../EventEmitter/NativeEventEmitter';\r\nimport logError from '../Utilities/logError';\r\nimport EventEmitter from '../vendor/emitter/EventEmitter';\r\nimport NativeAppState from './NativeAppState';\r\nimport invariant from 'invariant';\r\n\r\n/**\r\n * `AppState` can tell you if the app is in the foreground or background,\r\n * and notify you when the state changes.\r\n *\r\n * See https://reactnative.dev/docs/appstate.html\r\n */\r\nclass AppState extends NativeEventEmitter {\r\n  _eventHandlers: Object;\r\n  _supportedEvents = ['change', 'memoryWarning', 'blur', 'focus'];\r\n  currentState: ?string;\r\n  isAvailable: boolean;\r\n\r\n  constructor() {\r\n    super(NativeAppState);\r\n\r\n    this.isAvailable = true;\r\n    this._eventHandlers = this._supportedEvents.reduce((handlers, key) => {\r\n      handlers[key] = new Map();\r\n      return handlers;\r\n    }, {});\r\n\r\n    this.currentState = NativeAppState.getConstants().initialAppState;\r\n\r\n    let eventUpdated = false;\r\n\r\n    // TODO: this is a terrible solution - in order to ensure `currentState`\r\n    // prop is up to date, we have to register an observer that updates it\r\n    // whenever the state changes, even if nobody cares. We should just\r\n    // deprecate the `currentState` property and get rid of this.\r\n    this.addListener('appStateDidChange', appStateData => {\r\n      eventUpdated = true;\r\n      this.currentState = appStateData.app_state;\r\n    });\r\n\r\n    // TODO: see above - this request just populates the value of `currentState`\r\n    // when the module is first initialized. Would be better to get rid of the\r\n    // prop and expose `getCurrentAppState` method directly.\r\n    NativeAppState.getCurrentAppState(appStateData => {\r\n      // It's possible that the state will have changed here & listeners need to be notified\r\n      if (!eventUpdated && this.currentState !== appStateData.app_state) {\r\n        this.currentState = appStateData.app_state;\r\n        this.emit('appStateDidChange', appStateData);\r\n      }\r\n    }, logError);\r\n  }\r\n\r\n  // TODO: now that AppState is a subclass of NativeEventEmitter, we could\r\n  // deprecate `addEventListener` and `removeEventListener` and just use\r\n  // addListener` and `listener.remove()` directly. That will be a breaking\r\n  // change though, as both the method and event names are different\r\n  // (addListener events are currently required to be globally unique).\r\n  /**\r\n   * Add a handler to AppState changes by listening to the `change` event type\r\n   * and providing the handler.\r\n   *\r\n   * See https://reactnative.dev/docs/appstate.html#addeventlistener\r\n   */\r\n  addEventListener(type: string, handler: Function) {\r\n    invariant(\r\n      this._supportedEvents.indexOf(type) !== -1,\r\n      'Trying to subscribe to unknown event: \"%s\"',\r\n      type,\r\n    );\r\n\r\n    switch (type) {\r\n      case 'change': {\r\n        this._eventHandlers[type].set(\r\n          handler,\r\n          this.addListener('appStateDidChange', appStateData => {\r\n            handler(appStateData.app_state);\r\n          }),\r\n        );\r\n        break;\r\n      }\r\n      case 'memoryWarning': {\r\n        this._eventHandlers[type].set(\r\n          handler,\r\n          this.addListener('memoryWarning', handler),\r\n        );\r\n        break;\r\n      }\r\n\r\n      case 'blur':\r\n      case 'focus': {\r\n        this._eventHandlers[type].set(\r\n          handler,\r\n          this.addListener('appStateFocusChange', hasFocus => {\r\n            if (type === 'blur' && !hasFocus) {\r\n              handler();\r\n            }\r\n            if (type === 'focus' && hasFocus) {\r\n              handler();\r\n            }\r\n          }),\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a handler by passing the `change` event type and the handler.\r\n   *\r\n   * See https://reactnative.dev/docs/appstate.html#removeeventlistener\r\n   */\r\n  removeEventListener(type: string, handler: Function) {\r\n    invariant(\r\n      this._supportedEvents.indexOf(type) !== -1,\r\n      'Trying to remove listener for unknown event: \"%s\"',\r\n      type,\r\n    );\r\n    if (!this._eventHandlers[type].has(handler)) {\r\n      return;\r\n    }\r\n    this._eventHandlers[type].get(handler).remove();\r\n    this._eventHandlers[type].delete(handler);\r\n  }\r\n}\r\n\r\nfunction throwMissingNativeModule() {\r\n  invariant(\r\n    false,\r\n    'Cannot use AppState module when native RCTAppState is not included in the build.\\n' +\r\n      'Either include it, or check AppState.isAvailable before calling any methods.',\r\n  );\r\n}\r\n\r\nclass MissingNativeAppStateShim extends EventEmitter {\r\n  // AppState\r\n  isAvailable: boolean = false;\r\n  currentState: ?string = null;\r\n\r\n  addEventListener(type: string, handler: Function) {\r\n    throwMissingNativeModule();\r\n  }\r\n\r\n  removeEventListener(type: string, handler: Function) {\r\n    throwMissingNativeModule();\r\n  }\r\n\r\n  // EventEmitter\r\n  addListener() {\r\n    throwMissingNativeModule();\r\n  }\r\n\r\n  removeAllListeners() {\r\n    throwMissingNativeModule();\r\n  }\r\n\r\n  removeSubscription() {\r\n    throwMissingNativeModule();\r\n  }\r\n}\r\n\r\n// This module depends on the native `RCTAppState` module. If you don't include it,\r\n// `AppState.isAvailable` will return `false`, and any method calls will throw.\r\n// We reassign the class variable to keep the autodoc generator happy.\r\nconst AppStateInstance: AppState | MissingNativeAppStateShim = NativeAppState\r\n  ? new AppState()\r\n  : new MissingNativeAppStateShim();\r\n\r\nmodule.exports = AppStateInstance;\r\n"]},"metadata":{},"sourceType":"module"}