{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport * as LogBoxSymbolication from \"./LogBoxSymbolication\";\n\nvar LogBoxLog = function () {\n  function LogBoxLog(data) {\n    _classCallCheck(this, LogBoxLog);\n\n    this.symbolicated = {\n      error: null,\n      stack: null,\n      status: 'NONE'\n    };\n    this.level = data.level;\n    this.type = data.type;\n    this.message = data.message;\n    this.stack = data.stack;\n    this.category = data.category;\n    this.componentStack = data.componentStack;\n    this.codeFrame = data.codeFrame;\n    this.isComponentError = data.isComponentError;\n    this.count = 1;\n  }\n\n  _createClass(LogBoxLog, [{\n    key: \"incrementCount\",\n    value: function incrementCount() {\n      this.count += 1;\n    }\n  }, {\n    key: \"getAvailableStack\",\n    value: function getAvailableStack() {\n      return this.symbolicated.status === 'COMPLETE' ? this.symbolicated.stack : this.stack;\n    }\n  }, {\n    key: \"retrySymbolicate\",\n    value: function retrySymbolicate(callback) {\n      if (this.symbolicated.status !== 'COMPLETE') {\n        LogBoxSymbolication.deleteStack(this.stack);\n        this.handleSymbolicate(callback);\n      }\n    }\n  }, {\n    key: \"symbolicate\",\n    value: function symbolicate(callback) {\n      if (this.symbolicated.status === 'NONE') {\n        this.handleSymbolicate(callback);\n      }\n    }\n  }, {\n    key: \"handleSymbolicate\",\n    value: function handleSymbolicate(callback) {\n      var _this = this;\n\n      if (this.symbolicated.status !== 'PENDING') {\n        this.updateStatus(null, null, null, callback);\n        LogBoxSymbolication.symbolicate(this.stack).then(function (data) {\n          _this.updateStatus(null, data == null ? void 0 : data.stack, data == null ? void 0 : data.codeFrame, callback);\n        }, function (error) {\n          _this.updateStatus(error, null, null, callback);\n        });\n      }\n    }\n  }, {\n    key: \"updateStatus\",\n    value: function updateStatus(error, stack, codeFrame, callback) {\n      var lastStatus = this.symbolicated.status;\n\n      if (error != null) {\n        this.symbolicated = {\n          error: error,\n          stack: null,\n          status: 'FAILED'\n        };\n      } else if (stack != null) {\n        if (codeFrame) {\n          this.codeFrame = codeFrame;\n        }\n\n        this.symbolicated = {\n          error: null,\n          stack: stack,\n          status: 'COMPLETE'\n        };\n      } else {\n        this.symbolicated = {\n          error: null,\n          stack: null,\n          status: 'PENDING'\n        };\n      }\n\n      if (callback && lastStatus !== this.symbolicated.status) {\n        callback(this.symbolicated.status);\n      }\n    }\n  }]);\n\n  return LogBoxLog;\n}();\n\nexport default LogBoxLog;","map":{"version":3,"sources":["D:/khaled/Matriels/Third Year/Second term/CS303/CS303-Project-1/node_modules/react-native/Libraries/LogBox/Data/LogBoxLog.js"],"names":["LogBoxSymbolication","LogBoxLog","data","symbolicated","error","stack","status","level","type","message","category","componentStack","codeFrame","isComponentError","count","callback","deleteStack","handleSymbolicate","updateStatus","symbolicate","then","lastStatus"],"mappings":"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","sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\n'use strict';\r\n\r\nimport * as LogBoxSymbolication from './LogBoxSymbolication';\r\n\r\nimport type {\r\n  Category,\r\n  Message,\r\n  ComponentStack,\r\n  CodeFrame,\r\n} from './parseLogBoxLog';\r\nimport type {Stack} from './LogBoxSymbolication';\r\n\r\ntype SymbolicationStatus = 'NONE' | 'PENDING' | 'COMPLETE' | 'FAILED';\r\n\r\nexport type LogLevel = 'warn' | 'error' | 'fatal' | 'syntax';\r\n\r\nexport type LogBoxLogData = $ReadOnly<{|\r\n  level: LogLevel,\r\n  type?: ?string,\r\n  message: Message,\r\n  stack: Stack,\r\n  category: string,\r\n  componentStack: ComponentStack,\r\n  codeFrame?: ?CodeFrame,\r\n  isComponentError: boolean,\r\n|}>;\r\n\r\nclass LogBoxLog {\r\n  message: Message;\r\n  type: ?string;\r\n  category: Category;\r\n  componentStack: ComponentStack;\r\n  stack: Stack;\r\n  count: number;\r\n  level: LogLevel;\r\n  codeFrame: ?CodeFrame;\r\n  isComponentError: boolean;\r\n  symbolicated:\r\n    | $ReadOnly<{|error: null, stack: null, status: 'NONE'|}>\r\n    | $ReadOnly<{|error: null, stack: null, status: 'PENDING'|}>\r\n    | $ReadOnly<{|error: null, stack: Stack, status: 'COMPLETE'|}>\r\n    | $ReadOnly<{|error: Error, stack: null, status: 'FAILED'|}> = {\r\n    error: null,\r\n    stack: null,\r\n    status: 'NONE',\r\n  };\r\n\r\n  constructor(data: LogBoxLogData) {\r\n    this.level = data.level;\r\n    this.type = data.type;\r\n    this.message = data.message;\r\n    this.stack = data.stack;\r\n    this.category = data.category;\r\n    this.componentStack = data.componentStack;\r\n    this.codeFrame = data.codeFrame;\r\n    this.isComponentError = data.isComponentError;\r\n    this.count = 1;\r\n  }\r\n\r\n  incrementCount(): void {\r\n    this.count += 1;\r\n  }\r\n\r\n  getAvailableStack(): Stack {\r\n    return this.symbolicated.status === 'COMPLETE'\r\n      ? this.symbolicated.stack\r\n      : this.stack;\r\n  }\r\n\r\n  retrySymbolicate(callback?: (status: SymbolicationStatus) => void): void {\r\n    if (this.symbolicated.status !== 'COMPLETE') {\r\n      LogBoxSymbolication.deleteStack(this.stack);\r\n      this.handleSymbolicate(callback);\r\n    }\r\n  }\r\n\r\n  symbolicate(callback?: (status: SymbolicationStatus) => void): void {\r\n    if (this.symbolicated.status === 'NONE') {\r\n      this.handleSymbolicate(callback);\r\n    }\r\n  }\r\n\r\n  handleSymbolicate(callback?: (status: SymbolicationStatus) => void): void {\r\n    if (this.symbolicated.status !== 'PENDING') {\r\n      this.updateStatus(null, null, null, callback);\r\n      LogBoxSymbolication.symbolicate(this.stack).then(\r\n        data => {\r\n          this.updateStatus(null, data?.stack, data?.codeFrame, callback);\r\n        },\r\n        error => {\r\n          this.updateStatus(error, null, null, callback);\r\n        },\r\n      );\r\n    }\r\n  }\r\n\r\n  updateStatus(\r\n    error: ?Error,\r\n    stack: ?Stack,\r\n    codeFrame: ?CodeFrame,\r\n    callback?: (status: SymbolicationStatus) => void,\r\n  ): void {\r\n    const lastStatus = this.symbolicated.status;\r\n    if (error != null) {\r\n      this.symbolicated = {\r\n        error,\r\n        stack: null,\r\n        status: 'FAILED',\r\n      };\r\n    } else if (stack != null) {\r\n      if (codeFrame) {\r\n        this.codeFrame = codeFrame;\r\n      }\r\n\r\n      this.symbolicated = {\r\n        error: null,\r\n        stack,\r\n        status: 'COMPLETE',\r\n      };\r\n    } else {\r\n      this.symbolicated = {\r\n        error: null,\r\n        stack: null,\r\n        status: 'PENDING',\r\n      };\r\n    }\r\n\r\n    if (callback && lastStatus !== this.symbolicated.status) {\r\n      callback(this.symbolicated.status);\r\n    }\r\n  }\r\n}\r\n\r\nexport default LogBoxLog;\r\n"]},"metadata":{},"sourceType":"module"}